多个设备可能同时访问一个数据或者结构体等，可能会出问题，于是引出原子操作，自旋锁，信号量，互斥体概念

## 原子操作：

在读取一个整形变量时可能同时被另外一个进程读取，导致结果出问题，原子操作可以保证单个的变量读取不会受干扰，原子操作包含整形变量的操作和位操作

## 自旋锁：

像结构体一类的读写，原子操作不能胜任，可以使用自旋锁

### 自旋锁特点：

1. 获取不到自旋锁的线程不会进入休眠或做其他处理，而是一直等待，所以叫自旋锁，**所以自旋锁保护的临界区要尽可能短**，于是可以通过使用自旋锁保护临界区只修改一个状态变量的值来达到控制效果，如，在驱动打开设备中使用一次上锁解锁来修改一个状态变量，设备操作完毕，在驱动释放时再调用一次上锁解锁修改回状态变量值来实现一次控制效果

2. 在使用自旋锁时尽量关闭中断并记下关闭时中断状态，在解锁时恢复中断状态

## 信号量：

信号量举例：停车场100个车位，车位为信号量，车为线程。一辆车进来，车位减一，直到减为0，外面的车需要等待，但不像自旋锁那样死等，而是可以进入休眠，有车出去，车位加一

### 信号量特点：

1. 信号量会使线程休眠，所以，适用于占用资源比较久的场合，对立与自旋锁
2. 信号量不能用于中断中使用，因为中断不能休眠
3. 共享资源持续时间比较短的话不适用信号量，因为来回切换线程的休眠开销会更大
4. 可以设置进入休眠状态的线程能否被信号打断

## 互斥体：

将信号量最大值设置为1，就等效与互斥体，但最好这种情况下就用互斥体

## 以上四者的led实验（linux并发与竞争实验）分析：

具体实验细节参考文档

### 原子操作实验：

在open函数中将一个原子变量减1，在release中将该原子变量加一，其他线程通过判断此变量是否为1来确定是否能打开该设备

**精髓在于：整形变量加减时不会被别的线程打扰！！！**

### 自旋锁实验：

在open函数中通过打开关闭自旋锁，在打开关闭中间将一个普通状态变量减1；在release中通过打开关闭自旋锁，在打开关闭中间将这个普通状态变量加1；其他线程通过判断该变量是否为1来确定能否打开该设备

**精髓在于：变量修改使用正常方式修改，但使用了自旋锁的保护，使其修改的时候不会被其他线程打乱，进而达到原子操作同样的效果，但比原子操作一次性可操作的内容多。**

### 信号量实验：

在open函数中获取一个信号量（获取方式有两种，休眠线程可被信号打断和不可被打断），在release中释放一个信号量，其他线程通过判断信号量值是否为0来决定是否进入休眠，实验效果为后台运行一个程序，信号量被获取，第二个程序运行进入休眠，等到前线程结束立刻开始运行

**精髓在于：在open与release之间的设备操作被信号量保护，对应与信号量的特点：适用于资源占用比较久的场合（open，release之间包含整个设备的操作过程，相对与前两者比较久）。**

### 互斥体实验：

类似于信号量实验



