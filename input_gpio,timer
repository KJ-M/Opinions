# 按键输入实验

## 设备树修改

参考led，beep修改设备树，编译完后加载进去查看设备树节点是否存在（设置正常）

## 驱动程序

重点：

使用原子操作设置一个原子变量保存按键状态，在read中检测按键状态，按下即原子操作改变按键状态值

```c
static ssize_t key_read (struct file *file, char __user *buf, size_t count, loff_t *offset)
{
    int ret = 0;
    int value;
    struct key_dev *dev = file->private_data;
    if(gpio_get_value(dev->key_gpio) == 0) {
        while(!gpio_get_value(dev->key_gpio));//等待按键释放
        atomic_set(&dev->keyvalue, KEY0VALUE);
    } else {
        atomic_set(&dev->keyvalue, INVAKEY);
    }
    value = atomic_read(&dev->keyvalue);
    ret = copy_to_user(buf, &value, sizeof(value));
    return ret;
}
```



## 测试app

测试app中打开设备后while循环里不断read按键值，读取到按下则输出，否则不输出

```c
/* 循环读取按键值数据 */
    while(1) {
        read(fd, &keyvalue, sizeof(keyvalue));
        if(keyvalue == KEY0VALUE) {
            printf("KEY0 Press, value = %#X\r\n", keyvalue);
        }
    }
```



# 内核定时器

​	驱动编写不必深究linux时钟配置问题，会用api函数即可