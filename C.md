## 重入

**重入可以理解为一个函数在同一时间被多次调用**，如操作系统在进程调度中，单片机、处理器中断时可能发生

一般浮点数运算都由专门硬件完成，假设有个寄存器为FLOAT，用来计算和存放浮点数中间运算结果，如果函数`void fun(){//对FLOAT操作}`，第一次执行，临时结果保存在FLOAT中，此时中断发生，调用fun，改变FLOAT结果，这样返回第一次fun时结果就会出问题。可以把fun理解为printf函数。

## Heap和Stack，静态区区别

### 基本特征：

**Heap是堆，Stack是栈，static（全局区）静态区**。

- 栈区Stack：空间由系统自动分配/释放，类似于数据结构的栈，存放函数参数值、局部变量值等，**stack空间有限**，自由度小
- 堆区Heap：一般由程序员手动分配和释放，或者系统回收，分配方式类似于链表，**Heap是很大的自由存储区**，malloc函数分配的内存空间即在堆上，自由度大
- 全局区（静态区）static:全局变量和静态变量存放在一块，初始化的全局和静态变量在一块区域，未初始化的全局和静态变量在相邻的另一块区域，程序结束后由系统释放
- 其他有：
  - 文字常量区：存放常量字符串，程序结束由系统释放
  - 程序代码区：存放函数体的二进制代码

### **经典例子**：

```c
int a = 0; //**全局初始化区** 

char *p1;//**全局未初始化区** 

void main(void)

{

 int b; //**栈** 

 char s[] = "abc"; //**栈** 

 char *p2; //**栈** 

 char *p3 = "123456"; //**123456\0在常量区，p3在栈上**

 static int c =0; //**全局（静态）初始化区** 

 p1 = (char *)malloc(10); //**堆** 

 p2 = (char *)malloc(20); //**堆**
    
 //以上分配来的10和20字节存在堆区
 
 strcpy(p1, "123456");
 
 //123456存放在常量区，编译器会将它和p3指向的123456优化成同一个地方

}
```

### 堆和栈存取效率比较：

```c
char s1[] = "aaaaaa";	//类似于上面的s[]
char *s2 = "bbbbbb"		//类似于上面的p3,p1
```

aaaaaa是在运行时刻赋值，bbbbbb是在编译时确定，但在以后存取中，在栈上的数组比指针所指向的字符串(例如堆)快

## sizeof和strlen区别

sizeof是运算符，在编译时即计算好了；strlen是函数，要在运行时才能计算

***研究一下这两个函数的使用方法***

## 大端小端（big endian&little endian）

用大小端表示0x12345678

| little endian(大大小小) | big endian（大小大小） |
| ----------------------- | :--------------------- |
| 高地址->0x12            | 0x78                   |
| 0x34                    | 0x56                   |
| 0x56                    | 0x34                   |
| 低地址->0x78            | 0x12                   |

## 函数调用时参数传递方式

参数<=4时，使用R0-R3寄存器传参，>4时，通过压栈方式传递

## 中断和异常的区别

异常：在产生时要考虑与处理器的时钟同步，异常也被成为同步中断，在处理器执行到由于编程失误而导致的错误指令时，或者在执行过程中出现特殊情况（如缺页），必须靠内核处理的时候，处理器就会产生一个异常。

中断：可以是外部硬件产生一个电信号，从cpu引脚进入，打断cpu当前的运行，异常是软件运行过程中产生一些必须做处理的事件，CPU自动产生一个陷入来打断当前的运行，转入异常处理流程

## 优先级反转

？？？

## 预处理#define声明一个常数，用以表示一年有多少秒（忽略闰年问题）

```c
#define SECONDS_PER_YEAR (60*60*24*365)UL	
```

注意：

1. #define语法基本知识（不加分号，括号使用）
2. 懂预处理会为你计算常数表达式的值，因此直接写计算公式更清晰
3. 将这个表达式会使一个16位整形数溢出，因此要用长整形符号L，告诉编译器这个常数是长整形数
4. UL代表无符号长整形，这样使用是个好习惯

## 写一个标准宏MIN，这个宏输入两个参数返回较小的一个

```c
#define MIN(A,B) ((A) <= (B) ? (A) : (B))
```

1. 宏是方便产生嵌入代码的唯一方法，为了达到要求的性能，嵌入代码经常是必须的方法
2. 三重条件操作符使用方法，比if-then-else更优化
3. 懂得在宏中把参数用括号括起来

## 用变量a给出一系列的定义

1. 一个整型数(An integer)

2. 一个指向整型数的指针(A pointer to an integer)

3. 一个指向指针的指针，它指向的指针是个整形数(A pointer to a pointer to an integer)

4. 一个有10个整型数的数组(An array of 10 integers)

5. **一个有10个指针的数组，该指针指向一个整型数的(An array of 10 pointers to integers)**

6. **一个指向有10个整形数数组的指针(A pointer to an array of 10 integers)**

7. 一个指向函数的指针，该函数有一个整形参数并返回一个整型数(a pointer to a function that takes an integer as an argument and returns an integer)

8. 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数(An array of ten pointers to functions that take an integer argument and return an integer)

   ```c
   int a	//1.
   int *a	//2.
   int **a	//3.
   int a[10]	//4.
   int *a[10]	//5.
   int (*a)[10]	//6.
   int (*a)(int)	//7.
   int (*a[10])(int) //8.   
   ```

## 关键词static作用

C语言中有三个明显作用

- 函数体内，一个被声明为静态的变量在调用过程中值维持不变
- 在模块内（函数体外），可以被模块内所有函数访问，但不能被模块外其他函数访问，是一个本地的全局变量
- 模块内，一个被声明静态的函数只可被这一模块内其他函数调用，即这个函数被限制在声明它的模块本地范围内使用

static全局变量与普通全局变量区别：**static全局变量只初始化一次，防止在其他文件单元被引用**

static局部变量和普通局部变量有什么区别：**static局部变量只被初始化一次**，**下一次依据上一次结果值**；
   static函数与普通函数有什么区别：**static函数在内存中只有一份**，**普通函数在每个被调用中维持一份拷贝**

## 关键词const作用

const意味着只读

```c
const int a;	//a为一个常整型数
int const a;	//等效上面
const int *a;	//a为指向常整形的指针，整型数不可修改，指针可以修改
				//a is a pointer to const int
int *const a;	//a为指向整型数的常指针，整型数可修改，指针不可修改（以上相反）			//a is a const pointer to int 
int const *a const;	//a为指向常整形的常指针，指针整型数都不可修改
```

合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。

## volatile作用

见onenote笔记

## 位操作方法

给一个整型a，第一段代码设置abit3，第二个清除abit3

```c
static int a;
void set_bit3(void)
{
    a |= (1<<3);
}
void clear_bit3(void)
{
    a &= ~(1<<3);
}
```

**注意static int a中static要使用；**

## 访问特定物理地址并设置值

设置一绝对地址为0x67a9的整型变量值为0xaa66。编译器是一个纯粹ANSI编译器，写代码完成：

```c
int *ptr;
ptr = (int *)0x67a9;
*ptr = 0xaa55;
```

测试是否知道**为了访问一绝对地址而把一个整型数强制转化为一个指针是合法的**。

## 找出中断函数问题

**中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字 __interrupt。下面的代码就使用了__interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的**。
```c
__interrupt double compute_area (double radius) 
{
  double area = PI * radius * radius;
  printf("\nArea = %f", area);
  return area;
}
```



这个函数有太多的错误了，以至让人不知从何说起了：
1) ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。
2) ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。
3) 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。
4) 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。

## 无符号数据类型问题

**下面的代码输出是什么，为什么？**
```c
void foo(void)
{
  unsigned int a = 6;
  int b = -20;
  (a+b > 6) ? puts("> 6") : puts("<= 6");
}
```
这个问题测试你是否懂得C语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是 ">6"。原因是**当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型**。**因此-20变成了一个非常大的正整数**，所以该表达式 计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。

## int类型问题、
```c
unsigned int zero = 0;
unsigned int compzero = 0xFFFF; // complement of zero 
```
对于一个int型不是16位的处理器为说，上面的代码是不正确的。应编写如下：

unsigned int compzero = ~0;

这一问题真正能揭露出应试者是否懂得处理器字长的重要性。在我的经验里，好的嵌入式程序员非常准确地明白硬件的细节和它的局限，然而PC机程序往往把硬件作为一个无法避免的烦恼。

另外：

```c
int main(int argc, char argv[])
{
    unsigned int a = 0;
    unsigned int b = 0xffff;
    unsigned int c = ~a;
    unsigned int d = !a;
    printf("a,b,c:%#X,%#X,%#X,%#X\n", a,b,c,d);
}
在ubuntu下运行结果如下
  a,b,c:0,0XFFFF,0XFFFFFFFF,0X1  
```

## typedef和define相似部分的对比

```c
#define dPS struct s*
typedef struct s* tPS
```

二者都是定义dPS和tPS为一个指向结构体s的指针，哪种方法更好呢？

**typedef定义的更好**，因为：

```c
dPS p1,p2;	//展开后等效于 struct s* p1,p2
tPS p3,p4;	//展开后等效于 struct s* p1,struct s* p2
```

所以，typedef如愿定义了两个指针，而define定义了一个指针和一个结构体，易出错

## 进程和线程的区别：

1. 调度：线程作为调度和分配的基本单元，进程作为拥有资源的基本单位
2. 并发性：不仅进程可以并发执行，同一进程内的线程也可以并发执行
3. 拥有资源：进程是拥有资源的基本独立单元，线程不拥有资源，但可以访问进程内的资源
4. 在创建或撤销进程时，由于系统都要为之分配和回收内存资源，导致系统的开销明显大于创建或撤销线程时的开销

## 字符串复制函数：

```c
void strcopy(char *str, char *str1)
{
    if(*str1 == '\0') printf("error\n");
    char *sp1,*sp2;
    sp1 = str;
    sp2 = str1;
    while (*sp2 != '\0')
    {
        *sp1 = *sp2;
        sp1++;
        sp2++;
    }
    
}
```

## 字符串翻转函数：

## 结构体对齐大小问题

| char | bool | short | int  | unsigned int | float | long | double | long  long | 指针 |
| ---- | ---- | ----- | ---- | ------------ | ----- | ---- | ------ | ---------- | ---- |
| 1    | 1    | 2     | 4    | 4            | 4     | 4    | 8      | 8          | 4    |

**结构体对齐规则**

结构体中各个成员按照它们被声明的顺序在内存中顺序存储。

1)将结构体内所有数据成员的长度值相加，记为sum_a； 
2)将各数据成员内存对齐，按各自对齐模数而导致填充的字节数累加到和sum_a上，记为sum_b。对齐模数是【该数据成员所占内存】与【#pragma pack指定的数值】中的较小者。
3)将和sum_b向结构体模数对齐，该模数是【#pragma pack指定的数值】、【未指定#pragma pack时，系统默认的对齐模数8字节】和【结构体内部最大的基本数据类型成员】长度中数值较小者。**结构体的长度应该是该模数的整数倍**

如何计算结构体占内存大小

```c
#pragma pack(4) //linux下默认为4 
struct Test1  
{  
    char c;  
    short sh;  
    int a;  
    float f;  
    int *p;  
    char *s;  
    double d;  
};
```

计算方法：

总共占28Bytes。 c的偏移量为0（第一个元素偏移量都为0），占1个Byte。sh占2个Byte，它的对齐模数是2（2<4，取小者），存放起始地址应该是2的整数倍，因此c后填充1个空字符，sh的起始地址是2。a占4个Byte，对齐模数是4，因此接在sh后存放即可，偏移量为4。f占4个字节，对齐模数是4，存放地址是4的整数倍，起始地址是8。p,s的起始地址分别是12,16。d占8个字节，对齐模数是4（4<8)，d从偏移地址为20处存放。存放后结构体占28个字节，是4的整数倍不用补空字符。

**若出现：**

```c
struct test {
    char a;
    short b;
    char c;
    int d;
}
```

共占8byte，a偏移量为0，对齐模数为1，无填充，占1个byte。b占2byte，对齐模数2（2<4)，故存放在偏移地址2处，前面填充1。c占1byte，无填充。d占4byte，对齐模数4，故存在偏移地址8处，前面填充3byte。一共填充4byte，8+4=12,12是4的整数倍，故结构体占12byte。

## 笔试题目

### malloc函数用法：给出一段代码判断问题所在

### strcmp()函数

是根据ACSII码的值来比较两个字符串的；strcmp()函数首先将s1字符串的第一个字符值减去s2第一个字符，若差值为零则继续比较下去；若差值不为零，则返回差值

```c
#include <string.h>
 
int main(void)
{
	char *p="aBc";
	char *q="Abc";
	char *h="abc";
	
	printf("strcmp(p,q):%d\n",strcmp(p,q));
	printf("strcmp(p,h):%d\n",strcmp(p,h));
	
	return 0;	
}
 
//结果：
//strcmp(p,q):32
//strcmp(p,h):-32
```



