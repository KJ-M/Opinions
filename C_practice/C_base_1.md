# C语言内存

## 指针基础

### 指针修饰符
#### const    常量，只读，不能变

- const char *p = char const *p,

    p is a pointer to const char

    p可任意指向，但指向的内容不允许修改，类似于字符串“hello world!”

- char * const p = char *p const

    const p is a pointer to char

    p指向的位置固定，内容可变，一般为硬件资源，寄存器地址等

- const char * const p

    const p is a pointer to const char

    指向内容和位置都不许变,一般为ROM设备

## 数组

原理：另外一种对内存的操作方式，本质上跟指针是一样的

- int a[100]

a是个常量标签，不是指针，出现a = xxx时是错误的，a++也错（相当于a+=1）
### 初始化
#### int a[10] = 空间 
#### C语言{}的意义
- **C语言默认使用{}来表示空间，即看到{}要想到一整块的空间操作**
- int a[10] = {10,20,30}	//此步骤只是方便程序员操作，实际执行相当于逐一依次赋值,程序执行效率不变

#### char buf[10] = {'a','b','c'}	普通数组用法
此处涉及到字符串和数组，一定注意
- **字符串和数组重要区别：尾部有一个'\0'**

#### char buf[10] = {"abc"}	字符串用法
- “”作用是自动在abc末尾加上‘\0'

#### char buf[10] = "abc"
是上一种{"abc"}写法的简化版，等效

#### char buf[10] = "abc"与char *p = "abc"区别
- char *p = "abc"
原理：指针p指向了“abc”对应的地址
- char buf[10] = "abc"
原理：将“abc”的值依次赋值给buf[0],buf[1],buf[2]...而"abc"另外存在了与buf不同的位置
因此：若出若出现以下情况
p[2] = 'e'	错误，p指向的是const常量"abc"
buf[2] = 'e'	正确，buf就是个普通数组，可随意变
- char *p = "abc"编译的时候已经赋值，后者运行的时候依次赋值
所以char *p节省程序运行时间，后者多了赋值操作，费时；但是！经测试指针方式更占用可执行程序大小，而且，赋值后读取时数组方式存放在栈区，读取速度更快
具体细节见下方：####linux下程序中不同位置加减变量或数组测试出异常点

#### char buf[] = "abc"与以上带buf[10]的区别
带10数组固定分配10个值，不带编译器自动为数组分配值数量等于“abc”需要数量，此处为4个

### 初始化完后二次赋值
#### 分为字符空间和非字符空间拷贝
- 字符空间：使用ascii码来解码的空间-->给人看的空间，\0作为结束标志
- 非字符空间：解析成具体的数值
二者定义的时候养成习惯：
char buf[10];-->string
unsigned char buf[10];-->data

#### 字符空间拷贝原则
一块空间，当成字符空间时，C语言提供了一套字符拷贝函数
字符拷贝函数的原则：内存空间间的逐一赋值，一旦出现0，函数就即将结束

#### strcpy()
最基本的字符拷贝函数，使用时注意内存泄露问题，此函数看到0才结束

#### 非字符空间拷贝原则
三个：
src： source源地址
dest：destination目的地址
num：number拷贝个数

#### memcpy()
```c
void *memcpy(void *dest, const void *src, size_t n);//字符拷贝函数，以下是使用范例

int buf[10];
int sensor[100];
memcpy(buf, sensor, 10*sizeof(int));//n表示byte,故需要计算字节数目
//此处不使用strcpy或strnpy是因为这两个都会识别0为字符串结束标志，所以拷贝会出问题


```
### 指针数组char *a[100]
本质是数组里面存放了指针
int a[100]--->int 修饰a里面的每个值的类型a[0],a[1]...
char *a [100]--->char 修饰a[0],a[1]...里存放的指针指向内容的属性，即指向char类型的值对应地址
以上两个a，sizeof(a) = 100 x 4 

#### 指针数组和二维指针的关系 char **a
本质上是一样的，都是指向指针的指针
char **a 是一个指向指针的指针
char *a[100]是100个指向指针的指针

### 指针和数组原理性知识总结
#### 定义指针，分别表示 int a[10],int b[5][6]首地址
```c
int a[10];
int b[5][6];
int *p1 = a;	//正确
int **p2 = b;	//错误
int (*p)[6] = b;	//正确

```
#### C语言编译器本质是字符解释器，定义变量是基于变量名优先从右边解释
##### int a[10]
变量名a，往右[]，a即被解释为一个数组名，即成为了一个标签，具有数组的性质(有空查一下a怎么保存的)，此时数组a已经有名字，长度，右边没东西，往左看，有int，即为数组里面每个之对应的保存方式：int类型
即：数组三要素：名字，长度，组内每个值的保存方式（长度）

##### int *a
变量名a，往右没有，往左有*，表示a是个指针，具有指针性质，在往左，有int，表示从a对应的地址读取方式为int
即：指针三要素：名字，指针本身占内存大小，读取方式（一次读几个字节）
指针和数组三要素几乎等价

##### int *a[10]
变量名a，往右[]，a即为一个数组，具有数组性质，想象三要素，还差组内每个值的保存方式，再往右没有值，往左，有*，表示组内每个值保存方式为指针，此时要想到指针的三要素，指针名字为a[0],a[1]...每个指针的读取方式还没确定，再往左看，有int，即为指针指向的值的读取方式
即：a是一个数组，数组内每个值是个指针，每个指针指向内容读取方式为int

##### int **a
变量名a，右边没有东西，左侧第一个*，表示a是个指针，三要素还差读取方式，再左侧，*，表示读取方式为指针类型，该指针类型三要素还差读取方式，再往左侧，int，表示这个指针读取方式为int类型
即：a表示一个指针，指向一个存放指针变量的位置，存放的指针变量指向一个存放int类型的地址

##### int (*p)[10]
变量名p，有括号先看括号里的，*表示p是个指针，还差指向内容的读取方式，看右边，[],表示指针类型的读取方式是数组，此数组长度是10，此数组还差每个值的保存方式没有确定，此时看左侧，int，表示数组每个值保存为int类型
即：p表示一个指向数组的指针，该数组10个值，每个值保存一个int

#### 解释：始终记住指针和数组的本质
指针和数组都是用来处理内存操作的不同方式
声明时指针和数组都有三要素，见上面变量定义时的解释
##### 指针是否够表示数组名判断技巧
例如：
```c
int a[10];
int b[5][6];
int *p1 = a;	//p1+1,跨过一个int；a+1(a[1])，跨过一个int；故可用p1表示a
int **p2 = b;	//p2+1，跨过一个指针变量；b+1(b[1][6]),跨过6个int，故不可表示
int (*p)[6] = b;	//p+1,跨过6个int，b+1(b[1][6])，跨过6个int，故可表示

```

## 结构体
见onenote结构体部分笔记和[[C#结构体对齐大小问题]]

## 内存分布图
实际上是C语言中常用的几个section（段，程序或者变量存放的位置）
![](C语言内存分配图.png)

### size x.out查看x.out各段所占空间的大小

### 程序分debug版和release版的原因
#### 可执行文件大小由.text段和.data段决定
#### printf()中的“”字符所在内存也保存在text段，使用printf越多，text段越大
#### linux下程序中不同位置加减变量或数组测试出异常点：
- bss，data，text段加减大小和所加变量可能不统一，但趋势和变化位置和前面分析一致
- 函数内声明的普通数组表示数据或字符串，初始化时为其赋值时，不管是使用"fsf422"或是{1,2,3...}，""或{}中的内容都是放在text段，增加的是可执行文件的大小
- 全局变量声明时char str6[10] = {"5451"}或char str6[10] = {1，2，3}不会增加text段
- 全局变量声明时char *p = "dfdsfs"会增加text段
- 函数内静态变量声明时与以上全局变量的两点完全一样，因为二者存放位置一样

### 函数内static和全局变量存放位置一样，区别在于
函数内static是局部变量，若两个函数内都有static int a，则两个a标签后缀名不一样，所以从来不用考虑不同函数中声明两个相同的static变量

### 使用nm -n查看函数中各个符号所在位置

### 堆空间的分配和释放
#### malloc()一旦申请成功，返回地址，
```c
char *p
p = (char *)malloc(5*sizeof(int))
if(p == NULL)	
	error
```
#### 释放
free()

## 函数名，数组名
```c
#include <stdio.h>		//数组名取地址+1测试
int main(void)
{
	int a[40];
	printf("a:%p\n", a);
	printf("&a:%p\n", &a);
	printf("a+1:%p\n", a+1);
	printf("&a+1:%p\n", &a+1);
	return 0;
}
$ ./001.exe
a:000000000022FDB0
&a:000000000022FDB0
a+1:000000000022FDB4
&a+1:000000000022FE50
&a+1 - &a = 160 = 4 * 40 （数组名取地址后的指针加一相当于加整个数组的大小）

#include <stdio.h>		//函数名取地址+1测试
int test(int a, int b)
{
	return a+b;
}
int main(void)
{
	printf("test:%p\n", test);
	printf("&test:%p\n", &test);
	printf("test+1:%p\n", test+1);
	printf("&test+1:%p\n", &test+1);
	return 0;
}
$ ./001.exe
test:0000000000401550
&test:0000000000401550
test+1:0000000000401551
&test+1:0000000000401551	（函数名取地址后指针加一相当于函数名代表的地址+1，跟数组不同）

```

总结：
所以数组名和数组名取地址虽然一样，但意义不一样
数组名代表数组第一个元素地址
数组名取地址代表指向整个数组的指针，相当于前面介绍的 int (*p)[10]
函数名取地址代。。。先记住现象吧，研究意义不大，因为之前就不允许对函数名字取地址
用到的是函数指针，见onenote
### 函数名，数组名，变量名都是些标识符，在编译到最后都会使用地址代替，不存在储存这些名的问题

## 函数指针相关
https://blog.csdn.net/dagefeijiqumeiguo/article/details/73393369

## 数据在计算机中的储存形式（补码）
### 补码基础:
补码就是为了解决计算机中的减法问题
- 在有模运算体系中（类似钟表，模为12），两个数的和等于模，则这两个数互为补数
- 有模运算中，减去一个数等于加上这个数的补数，于是引出补码

补码定义：
补码 = 模 + 真值
设模为M，一个数X的补码定义为【X】补 = M +X
- 若X>0,则模作为超出的部分就被舍去，【X】补 = X，故整数补码为其本身
- 若X<0，则【X】补就是以M为模的补数	

怎么确定模：
模是所有能表示出来的数据总个数，如四位处理器0000-1111共16中组合，则模为16

注意特殊值：
如8位计算机
-1补码：1111 1111
-128补码：1000 0000
-128源码：不存在，故16位有符号取值范围负数比正数多一个

数据在计算机中都是以补码的形式储存的
如int b = -7;printf("\n%x", b);为fffffff9，为-7的补码
补码计算：
正数和0为其本身
负数补码：
先求反码：符号位1不变，后面的取反
补码=反码+1
例：
-2
80 00 00 02 原
ff ff ff fd 反
ff ff ff fe 补
int a = 10;
unsigned int b = -5;
a+b值为正，且数值很大，因为无符号和有符号相加会把有符号转化为无符号，然后再加,没有转化过程，只是把最高位即符号位当成数据位处理：
-1+5：
-1补：ff ff ff ff
5 补：00 00 00 05
和 ：100 00 00 04 = 4

-6 + 5：
-6补：ff ff ff fa
5 补：00 00 00 05
和：  ff ff ff ff